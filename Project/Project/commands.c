#include <avr/io.h>
#include <util/delay.h>
#include "commands.h"

	#define PRESCALER 8 // Предделитель
	#define TIME_MULTIPLIER 1.2 // Множитель времени (1.2 мс)
	
	
void command(uint8_t temp)
{


	uint8_t tik_const[243] = {252,364,396,424,454,482,514,598,630,658,690,776,806,834,866,892,924,952,984,1070,1100,1186,1218,1244,1276,1304,1336,1366,1396,1480,1512,1598,1628,1656,1688,1716,1748,1776,1808,1834,1866,1894,1926,1954,1986,2014,2046,2072,2104,2132,2164,2194,2224,2252,2284,2310,2342,2370,2402,2486,2518,2546,2578,2608,2638,2666,2698,2724,2756,2784,2816,2844,2876,2904,2936,3022,3052,3080,3112,3138,3170,3198,3230,3258,3290,3318,3350,3436,3466,3550,3582,3668,3698,3784,3816,3900,3930,4016,4048,4076,4106,4134,4166,4194,4226,4310,4342,4372,4402,4430,4462,4488,4520,4548,4580,4608,4640,4668,4700,4726,4758,4786,4818,4904,4934,5018,5050,5080,5110,5138,5170,5196,5228,5256,5288,5316,5348,5376,5410,5434,5466,5552,5584,5612,5642,5670,5702,5786,5818,5846,5878,5908,5938,5966,5998,6024,6056,6084,6116,6144,6176,6204,6236,6322,6352,6380,6412,6438,6470,6498,6530,6558,6590,6618,6650,6676,6708,6736,6768,6796,6826,6854,6886,6916,6946,6974,7006,7032,7064,7092,7124,7152,7184,7212,7244,7270,7302,7330,7362,7390,7420,7448,7480,7510,7540,7568,7600,7626,7658,7686,7718,7746,7778,7806,7838,7864,7896,7924,7956,7986,8016,8044,8076,8102,8134,8162,8194,8222,8254,8338,8370,8456,8486,8572,8604,8630,8662,8746,8778,8808,8838,8922,8954};


		// Установка PD5 (OC1A) в качестве выхода
		DDRD |= (1<<5);
		//PORTD |= (1<<5);
		

		// Установка режима CTC с предделителем 8
		TCCR1B |= (1 << WGM12); // Установка режима CTC
		TCCR1B |= (1 << CS11); // Установка предделителя 8

		// Установка выходного сравнения с непрерывным сравнением (по умолчанию) для OC1A (PD5)
		TCCR1A |= (1 << COM1A0);

		uint8_t index = 0;
		while (1)
		{
			// Расчет и установка значения регистра сравнения для заданной ширины сигнала
			uint16_t compare_value = (uint16_t)((F_CPU / 1000.0) * (TIME_MULTIPLIER * tik_const[index]) / PRESCALER) - 1;
			OCR1A = compare_value;

			// Ожидаем, пока счетчик достигнет значения сравнения
			while (!(TIFR1 & (1 << OCF1A)));

			// Сбрасываем флаг сравнения
			TIFR1 |= (1 << OCF1A);

			// Инвертируем выходное значение OC1A (PD5) для нечетных индексов массива
			if (index % 2 != 0)
			{
				PORTD ^= (1 << 5);
			}

			// Переключаемся на следующее значение массива
			index = (index + 1) % 139;
		}
	}